/**
 * Program to autogenerate JEMCC prototype files based on Java class input.
 * Copyright (C) 2000-2004 J.M. Heisz 
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * See the file named COPYRIGHT in the root directory of the source
 * distribution for specific references to the GNU General Public License,
 * as well as further clarification on your rights to use this software.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/**
 * NOTE: the above only applies to the copyright ownership for this file
 * (and associated program).  It does *NOT* apply to any output generated
 * by the program from whatever input files you choose to provide (as described
 * in the COPYRIGHT file in the root of the distribution).  The embedded 
 * copyright information (generated by the -c option) is only provided for
 * the convenience of the author in the generation of the JEMCC-specific class
 * instances.
 */
#include "jeminc.h"

/* Read the jni/jem internal details */
#include "jem.h"

#define CL_CONSTANT(x) pData->constantPool[x - 1]

/* Local storage for parsing exception messages */
static char stdThrowableMessage[1024];

/* Forward declarations */
char *extractClassBaseName(char *origName);
void buildMethodDesc(char *buffer, JEM_ParsedClassData *pData,
                     JEM_ParsedMethodData *mData);

/* Produce the JEMCC skeleton file based on the source Java instance */
int main(int argc, char *argv[]) {
    int i, j, rc, genCopyright, len, cnt, index, methodCount, fieldCount;
    char *ptr, *classFile, *className, lineBuff[1024];
    char *dataBuff = (char *) malloc(128 * 1024);
    JEM_ParsedMethodData mswp;
    JEM_ParsedClassData *pData;
    FILE *fp;

    /* Process the command argument list */
    genCopyright = 0;
    classFile = NULL;
    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-c") == 0) {
            genCopyright = 1;
        } else {
            classFile = argv[i];
        }
    }
    if (classFile == NULL) {
        (void) fprintf(stderr, "\nUsage: %s [-c] <class_file>\n\n", argv[0]);
        exit(1);
    }

    /* Read the contents of the file */
    if ((fp = fopen(classFile, "rb")) == NULL) {
        (void) fprintf(stderr, "Cannot read specified class file: %s\n", 
                               classFile);
        exit(1);
    }
    len = fread(dataBuff, 1, 128 * 1024, fp);
    (void) fclose(fp);

    /* Parse it */
    if ((pData = JEM_ParseClassData(NULL, dataBuff, len)) == NULL) {
        (void) fprintf(stderr, "%s: got unexpected error '%s'\n",
                               argv[0], stdThrowableMessage);
        exit(1);
    }

    /* Grab the name for the copyright output */
    index = CL_CONSTANT(pData->classIndex).class_info.nameIndex;
    ptr = CL_CONSTANT(index).utf8_info.bytes;
    for (i = 0; i < strlen(ptr); i++) {
        if (ptr[i] == '/') ptr[i] = '.';
    }
    if (genCopyright != 0) {
        (void) fprintf(stdout, "/**\n");
        (void) fprintf(stdout, " * %cId%c\n", '$', '$');
        (void) fprintf(stdout, " *\n");
        (void) fprintf(stdout, 
                       " * JEMCC definitions of the %s class.\n", ptr);
        (void) fprintf(stdout, 
                       " * Copyright (C) 1999-2004 J.M. Heisz\n");
        (void) fprintf(stdout, " *\n");
        (void) fprintf(stdout, " * This library is free software; you can %s",
                               "redistribute it and/or\n");
        (void) fprintf(stdout, 
                       " * modify it under the terms of the GNU Lesser %s",
                       "General Public\n");
        (void) fprintf(stdout, 
                       " * License as published by the Free Software %s",
                       "Foundation; either\n");
        (void) fprintf(stdout, " * version 2.1 of the License, or (at your %s",
                               "option) any later version.\n");
        (void) fprintf(stdout, " *\n");
        (void) fprintf(stdout, " * See the file named COPYRIGHT in the root %s",
                               "directory of the source\n");
        (void) fprintf(stdout, " * distribution for specific references to %s",
                               "the GNU Lesser General Public\n");
        (void) fprintf(stdout, 
                       " * License, as well as further clarification %s",
                       "on your rights to use this\n");
        (void) fprintf(stdout, " * software.\n");
        (void) fprintf(stdout, " *\n");
        (void) fprintf(stdout, " * This library is distributed in the hope %s",
                               "that it will be useful,\n");
        (void) fprintf(stdout, " * but WITHOUT ANY WARRANTY; without even %s",
                               "the implied warranty of\n");
        (void) fprintf(stdout, " * MERCHANTABILITY or FITNESS FOR A %s",
                               "PARTICULAR PURPOSE.  See the GNU\n");
        (void) fprintf(stdout, " * Lesser General Public License for more %s",
                               "details.\n");
        (void) fprintf(stdout, " *\n");
        (void) fprintf(stdout, " * You should have received a copy of the %s",
                               "GNU Lesser General Public\n");
        (void) fprintf(stdout, " * License along with this library; if not, %s",
                               "write to the Free Software\n");
        (void) fprintf(stdout, " * Foundation, Inc., 59 Temple Place, Suite %s",
                               "330, Boston, MA  02111-1307 USA\n");
        (void) fprintf(stdout, " */\n");
    } else {
        (void) fprintf(stdout, 
                       "/* JEMCC definitions of the %s class. */\n\n", ptr);
        (void) fprintf(stdout, 
                       "/* Insert your copyright information here */\n\n");
    }

    (void) fprintf(stdout, "#include \"jeminc.h\"\n");
    (void) fprintf(stdout, "\n");
    (void) fprintf(stdout, "/* Read the structure/method details */\n");
    (void) fprintf(stdout, "#include \"jemcc.h\"\n\n");

    /* Process the package out of the classname */
    ptr = CL_CONSTANT(index).utf8_info.bytes;
    className = extractClassBaseName(ptr);

    /* Sort the class methods */
    cnt = 1;
    while (cnt != 0) {
        cnt = 0;
        for (i = 0; i < pData->methodsCount - 1; i++) {
            rc = strcmp(CL_CONSTANT(pData->methods[i + 
                                         1].nameIndex).utf8_info.bytes,
                        CL_CONSTANT(pData->methods[i
                                         ].nameIndex).utf8_info.bytes);
            if ((rc < 0) ||
                ((rc == 0) &&
                 (strcmp(CL_CONSTANT(pData->methods[i + 
                                          1].descIndex).utf8_info.bytes,
                         CL_CONSTANT(pData->methods[i
                                          ].descIndex).utf8_info.bytes) < 0))) {
                mswp = pData->methods[i];
                pData->methods[i] = pData->methods[i + 1];
                pData->methods[i + 1] = mswp;
                cnt++;
            }
        }
    }

    /* Write the method skeletons (only for non-interface/abstract) */
    methodCount = 0;
    for (i = 0; i < pData->methodsCount; i++) {
        if ((pData->methods[i].accessFlags & 
                                   (ACC_PUBLIC | ACC_PROTECTED)) == 0) {
            continue;
        }
        methodCount++;
        if (((pData->classAccessFlags & ACC_INTERFACE) == 0) &&
            ((pData->methods[i].accessFlags & ACC_ABSTRACT) == 0)) {
            (void) sprintf(lineBuff, "static jint JEMCC_%s_", className);
            buildMethodDesc(lineBuff, pData, &(pData->methods[i]));
            (void) fprintf(stdout, "%s(JNIEnv *env,\n", lineBuff);
            for (j = 0; j < strlen(lineBuff) + 1; j++) {
                (void) fprintf(stdout, " ");
            }
            (void) fprintf(stdout, "JEMCC_VMFrame *frame,\n");
            for (j = 0; j < strlen(lineBuff) + 1; j++) {
                (void) fprintf(stdout, " ");
            }
            (void) fprintf(stdout, "JEMCC_ReturnValue *retVal) {\n");
            (void) fprintf(stdout, "    JEMCC_ThrowStdThrowableIdx(env, ");
            (void) fprintf(stdout, "JEMCC_Class_Throwable,\n");
            (void) fprintf(stdout, "                               NULL, ");
            (void) fprintf(stdout, "\"TODO - not implemented\");\n");
            (void) fprintf(stdout, "    return JEMCC_ERR;\n}\n\n");
        }
    }

    /* Write the method definition table */
    if (methodCount != 0) {
        (void) fprintf(stdout, "JEMCC_MethodData JEMCC_%sMethods[] = {\n",
                               className);
        cnt = 0;
        for (i = 0; i < pData->methodsCount; i++) {
            if ((pData->methods[i].accessFlags & 
                                       (ACC_PUBLIC | ACC_PROTECTED)) == 0) {
                continue;
            }
            (void) fprintf(stdout, "    { ");
            if (pData->methods[i].accessFlags & ACC_PUBLIC) {
                (void) fprintf(stdout, "ACC_PUBLIC");
            } else {
                (void) fprintf(stdout, "ACC_PROTECTED");
            }
            if (pData->methods[i].accessFlags & ACC_STATIC) {
                (void) fprintf(stdout, " | ACC_STATIC");
            }
            if (pData->methods[i].accessFlags & ACC_FINAL) {
                (void) fprintf(stdout, " | ACC_FINAL");
            }
            if (pData->methods[i].accessFlags & ACC_SYNCHRONIZED) {
                (void) fprintf(stdout, " | ACC_SYNCHRONIZED");
            }
            if (pData->methods[i].accessFlags & ACC_ABSTRACT) {
                (void) fprintf(stdout, " | ACC_ABSTRACT");
            }
            (void) fprintf(stdout, ",\n");
            (void) fprintf(stdout, "         \"%s\", \"%s\",\n",
                     CL_CONSTANT(pData->methods[i].nameIndex).utf8_info.bytes,
                     CL_CONSTANT(pData->methods[i].descIndex).utf8_info.bytes);
            (void) sprintf(lineBuff, "JEMCC_%s_", className);
            if (pData->methods[i].accessFlags & ACC_ABSTRACT) {
                (void) fprintf(stdout, "         NULL }");
            } else {
                buildMethodDesc(lineBuff, pData, &(pData->methods[i]));
                (void) fprintf(stdout, "         %s }", lineBuff);
            }

            cnt++;
            if (cnt == methodCount) {
                (void) fprintf(stdout, "\n");
            } else {
                (void) fprintf(stdout, ",\n");
            }
        }
        (void) fprintf(stdout, "};\n");
    }

    /* Now write the field data, not nearly as sophisticated */
    fieldCount = 0;
    for (i = 0; i < pData->fieldsCount; i++) {
        if ((pData->fields[i].accessFlags & 
                                (ACC_PUBLIC | ACC_PROTECTED)) == 0) {
            continue;
        }
        fieldCount++;
    }
    if (fieldCount != 0) {
        (void) fprintf(stdout, "\nJEMCC_FieldData JEMCC_%sFields[] = {\n",
                               className);
        cnt = 0;
        for (i = 0; i < pData->fieldsCount; i++) {
            if ((pData->fields[i].accessFlags & 
                                    (ACC_PUBLIC | ACC_PROTECTED)) == 0) {
                continue;
            }
            (void) fprintf(stdout, "    { ");
            if (pData->fields[i].accessFlags & ACC_PUBLIC) {
                (void) fprintf(stdout, "ACC_PUBLIC");
            } else {
                (void) fprintf(stdout, "ACC_PROTECTED");
            }
            if (pData->fields[i].accessFlags & ACC_STATIC) {
                (void) fprintf(stdout, " | ACC_STATIC");
            }
            if (pData->fields[i].accessFlags & ACC_FINAL) {
                (void) fprintf(stdout, " | ACC_FINAL");
            }
            if (pData->fields[i].accessFlags & ACC_VOLATILE) {
                (void) fprintf(stdout, " | ACC_VOLATILE");
            }
            if (pData->fields[i].accessFlags & ACC_TRANSIENT) {
                (void) fprintf(stdout, " | ACC_TRANSIENT");
            }
            (void) fprintf(stdout, ", \"%s\", \"%s\", -1 }",
                     CL_CONSTANT(pData->fields[i].nameIndex).utf8_info.bytes,
                     CL_CONSTANT(pData->fields[i].descIndex).utf8_info.bytes);

            cnt++;
            if (cnt == fieldCount) {
                (void) fprintf(stdout, "\n");
            } else {
                (void) fprintf(stdout, ",\n");
            }
        }
        (void) fprintf(stdout, "};\n");
    }

    /* Finally, a notation for the class definition */
    (void) fprintf(stdout, "\n/*\nJEMCC_CreateStdClass(env, loader,\n");
    (void) fprintf(stdout, "                     ");
    if ((pData->classAccessFlags & ACC_PUBLIC) != 0) {
        (void) fprintf(stdout, "ACC_PUBLIC");
    } else if ((pData->classAccessFlags & ACC_PROTECTED) != 0) {
        (void) fprintf(stdout, "ACC_PROTECTED");
    } else {
        (void) fprintf(stdout, "ACC_PRIVATE");
    }
    if (pData->classAccessFlags & ACC_FINAL) {
        (void) fprintf(stdout, " | ACC_FINAL");
    }
    if (pData->classAccessFlags & ACC_INTERFACE) {
        (void) fprintf(stdout, " | ACC_INTERFACE");
    } else if (pData->classAccessFlags & ACC_ABSTRACT) {
        (void) fprintf(stdout, " | ACC_ABSTRACT");
    }
    (void) fprintf(stdout, ",\n");
    (void) fprintf(stdout, "                     \"%s\",\n",
                   CL_CONSTANT(index).utf8_info.bytes);
    if (pData->superClassIndex <= 0) {
        index = -1;
    } else {
        index = CL_CONSTANT(pData->superClassIndex).class_info.nameIndex;
    }
    (void) fprintf(stdout, "                     NULL ** %s **,\n",
                   ((index < 0) ? "NULL" : 
                                  (char *) CL_CONSTANT(index).utf8_info.bytes));
    if (pData->interfacesCount <= 0) {
        (void) fprintf(stdout, "                     interfaces, 0,\n");
    } else {
        (void) fprintf(stdout, "                     interfaces ** ");
        for (i = 0; i < pData->interfacesCount; i++) {
            index = CL_CONSTANT(pData->interfaces[i]).class_info.nameIndex;
            (void) fprintf(stdout, "%s, ", CL_CONSTANT(index).utf8_info.bytes);
        }
        (void) fprintf(stdout, " **, %i,\n", pData->interfacesCount);
    }
    if (methodCount > 0) {
        (void) fprintf(stdout, 
                       "                     JEMCC_%sMethods, %i, NULL,\n",
                       className, methodCount);
    } else {
        (void) fprintf(stdout, "                     NULL, 0, NULL,\n");
    }
    if (fieldCount > 0) {
        (void) fprintf(stdout, "                     JEMCC_%sFields, %i,\n",
                               className, fieldCount);
    } else {
        (void) fprintf(stdout, "                     NULL, 0,\n");
    }
    (void) fprintf(stdout, 
                   "                     NULL, 0, NULL, classInstance);\n*/\n");

    return 0;
}

char *extractClassBaseName(char *origName) {
    int i;

    for (i = strlen(origName) - 1; i >= 0; i--) {
        if ((origName[i] == '.') || (origName[i] == '/')) {
            return JEMCC_StrDupFn(NULL, origName + i + 1);
        }
    }
    return JEMCC_StrDupFn(NULL, origName);
}

void buildMethodDesc(char *buffer, JEM_ParsedClassData *pData,
                     JEM_ParsedMethodData *mData) {
    JEM_DescriptorData *dData, *wData, *aData;
    char *ptr;
    int foundArg, depth;

    ptr = CL_CONSTANT(mData->nameIndex).utf8_info.bytes;
    if (strcmp(ptr, "<init>") == 0) ptr = "init";
    (void) strcat(buffer, ptr);

    dData = JEM_ParseDescriptor(NULL, 
                  CL_CONSTANT(mData->descIndex).utf8_info.bytes,
                  NULL, NULL, JNI_TRUE);
    wData = dData->method_info.paramDescriptor;
    foundArg = 0;
    while (wData->generic.tag != DESCRIPTOR_EndOfList) {
        if (foundArg == 0) {
           (void) strcat(buffer, "_");
           foundArg = 1;
        }
        switch (wData->generic.tag) {
            case BASETYPE_Byte:
                (void) strcat(buffer, "B");
                break;
            case BASETYPE_Char:
                (void) strcat(buffer, "C");
                break;
            case BASETYPE_Double:
                (void) strcat(buffer, "D");
                break;
            case BASETYPE_Float:
                (void) strcat(buffer, "F");
                break;
            case BASETYPE_Int:
                (void) strcat(buffer, "I");
                break;
            case BASETYPE_Long:
                (void) strcat(buffer, "J");
                break;
            case BASETYPE_Short:
                (void) strcat(buffer, "S");
                break;
            case BASETYPE_Boolean:
                (void) strcat(buffer, "Z");
                break;
            case DESCRIPTOR_ObjectType:
                ptr = extractClassBaseName(wData->object_info.className);
                (void) strcat(buffer, ptr);
                JEMCC_Free(ptr);
                break;
            case DESCRIPTOR_ArrayType:
                depth = 0;
                aData = wData;
                while (aData->generic.tag == DESCRIPTOR_ArrayType) {
                    aData = aData->array_info.componentType;
                    depth++;
                }
                switch (aData->generic.tag) {
                    case BASETYPE_Byte:
                        (void) strcat(buffer, "ByteArray");
                        break;
                    case BASETYPE_Char:
                        (void) strcat(buffer, "CharArray");
                        break;
                    case BASETYPE_Double:
                        (void) strcat(buffer, "DoubleArray");
                        break;
                    case BASETYPE_Float:
                        (void) strcat(buffer, "FloatArray");
                        break;
                    case BASETYPE_Int:
                        (void) strcat(buffer, "IntArray");
                        break;
                    case BASETYPE_Long:
                        (void) strcat(buffer, "LongArray");
                        break;
                    case BASETYPE_Short:
                        (void) strcat(buffer, "ShortArray");
                        break;
                    case BASETYPE_Boolean:
                        (void) strcat(buffer, "BoolArray");
                        break;
                    case DESCRIPTOR_ObjectType:
                        ptr = aData->object_info.className;
                        ptr = extractClassBaseName(ptr);
                        (void) strcat(buffer, ptr);
                        (void) strcat(buffer, "Array");
                        JEMCC_Free(ptr);
                        break;
                    default:
                        (void) strcat(buffer, "XArray");
                        break;
                }
                while (depth > 1) {
                    (void) strcat(buffer, "Array");
                    depth--;
                }
                break;
            default:
                (void) strcat(buffer, "X");
                break;
        }
        wData++;
    }
}

/* Local methods to avoid full library inclusion */
void *JEMCC_Malloc(JNIEnv *env, juint size) {
    void *retVal = calloc(1, size);
    if (retVal == NULL) {
        (void) fprintf(stderr, "Memory allocation failure.\n");
        exit(1);
    }
    return retVal;
}

void JEMCC_Free(void *block) {
    free(block);
}

void *JEMCC_StrDupFn(JNIEnv *env, void *key) {
    char *retVal = strdup((char *) key);
    if (retVal == NULL) {
        (void) fprintf(stderr, "String memory allocation failure.\n");
        exit(1);
    }
    return retVal;
}

void JEMCC_ThrowStdThrowableIdx(JNIEnv *env, JEMCC_VMClassIndex idx,
                                JEMCC_Object *causeThrowable, const char *msg) {
    if (msg != NULL) {
        (void) strncpy(stdThrowableMessage, msg, 1023);
        stdThrowableMessage[1023] = '\0';
    } else {
        strcpy(stdThrowableMessage, "null");
    }
}
